{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Warning The following documentation is for a pre-release version of Candella. Some features and APIs may change over time and are not guaranteed to be stable. What makes Candella different? Release compatibility : Candella's release cycle syncs up with feature releases of Unscripted and the Ren'Py SDK, respectively. Responsive feedback : AliceOS follows a strict release schedule and doesn't update as quickly with bug fixes or improvements, Candella gets feedback from the public as well as playtesters in the Unscripted Playtesting Program . Targeted for Unscripted : Candella will add new features and improvements that will be helpful for Unscripted, such as native support for the NadiaVM language. Simplified app development : Candella's application framework extensions make it easier to develop apps quickly without fiddling through delegate calls, making projects from scratch, or remembering what keys are valid. There's even a curated project repository that players can download from and where developers can upload releases to. Try Candella today Candella is available in pre-release form via the Unscripted Playtesting Program and can be downloaded from Itch.io , but you can also build the source code locally to test drive the project. Build from source \u203a","title":"Home"},{"location":"#what-makes-candella-different","text":"Release compatibility : Candella's release cycle syncs up with feature releases of Unscripted and the Ren'Py SDK, respectively. Responsive feedback : AliceOS follows a strict release schedule and doesn't update as quickly with bug fixes or improvements, Candella gets feedback from the public as well as playtesters in the Unscripted Playtesting Program . Targeted for Unscripted : Candella will add new features and improvements that will be helpful for Unscripted, such as native support for the NadiaVM language. Simplified app development : Candella's application framework extensions make it easier to develop apps quickly without fiddling through delegate calls, making projects from scratch, or remembering what keys are valid. There's even a curated project repository that players can download from and where developers can upload releases to.","title":"What makes Candella different?"},{"location":"#try-candella-today","text":"Candella is available in pre-release form via the Unscripted Playtesting Program and can be downloaded from Itch.io , but you can also build the source code locally to test drive the project. Build from source \u203a","title":"Try Candella today"},{"location":"00-release-notes/","text":"Release Notes The following document contains information about the changes made, release per release, of Candella. v21.07 (Apple Cinnamon) This is the first initial relase of Candella. The following information contains the changes rolled up from all beta releases. Adds search functionality to Celeste Desktop's app drawer, filtered by name or bundle ID. Fixes a tagging issue in version injection scripts. Adds new CHANGELOG file to builds. Updates design language of notification banners in NotificationKit. Updates ScreenKit to new Candella design language. Changes behavior of CAApplication.send_banner to include automatic and manual modes. Rebuilds Candella against the Ren'Py 7.4.4 SDK.","title":"Release Notes"},{"location":"00-release-notes/#release-notes","text":"The following document contains information about the changes made, release per release, of Candella.","title":"Release Notes"},{"location":"00-release-notes/#v2107-apple-cinnamon","text":"This is the first initial relase of Candella. The following information contains the changes rolled up from all beta releases. Adds search functionality to Celeste Desktop's app drawer, filtered by name or bundle ID. Fixes a tagging issue in version injection scripts. Adds new CHANGELOG file to builds. Updates design language of notification banners in NotificationKit. Updates ScreenKit to new Candella design language. Changes behavior of CAApplication.send_banner to include automatic and manual modes. Rebuilds Candella against the Ren'Py 7.4.4 SDK.","title":"v21.07 (Apple Cinnamon)"},{"location":"01-getting-started/","text":"Getting started Quick start: Get Candella Unscripted comes bundled with the latest release of Candella and can be copied to any Ren'Py project. In the game's files, copy the 'candella.rpa' archive to your Ren'Py project. You can additionally download a release from the Releases page , or you can grab the latest release from Itch.io . Build from source Requirements Ren'Py SDK v7.4.0 or greater Python 3 Pipenv Clone the repository from GitHub, then run pipenv install -d in the root of the project to fetch dependencies for making the project. To build this project, open the Ren'Py Launcher, click \"Distribute\" and select \"Candella System Distributable\". The resulting file will be in a ZIP archive with candella.rpa . Test-drive features If you want to test out some of the features without building anything, clone the repository and launch the project from the Ren'Py launcher.","title":"Getting started"},{"location":"01-getting-started/#getting-started","text":"","title":"Getting started"},{"location":"01-getting-started/#quick-start-get-candella","text":"Unscripted comes bundled with the latest release of Candella and can be copied to any Ren'Py project. In the game's files, copy the 'candella.rpa' archive to your Ren'Py project. You can additionally download a release from the Releases page , or you can grab the latest release from Itch.io .","title":"Quick start: Get Candella"},{"location":"01-getting-started/#build-from-source","text":"","title":"Build from source"},{"location":"01-getting-started/#requirements","text":"Ren'Py SDK v7.4.0 or greater Python 3 Pipenv Clone the repository from GitHub, then run pipenv install -d in the root of the project to fetch dependencies for making the project. To build this project, open the Ren'Py Launcher, click \"Distribute\" and select \"Candella System Distributable\". The resulting file will be in a ZIP archive with candella.rpa .","title":"Requirements"},{"location":"01-getting-started/#test-drive-features","text":"If you want to test out some of the features without building anything, clone the repository and launch the project from the Ren'Py launcher.","title":"Test-drive features"},{"location":"02-caberto-shell/","text":"{HIDE} Celeste Shell The default desktop shell for Candella is Celeste (formerly known as Caberto Shell). Celeste's interface is mainly inspired from the Lomiri desktop environment and comes with per-user customizations. Warning Celeste is currently in a pre-release state and the documentation here may change as the project evolves. Using Celeste Shell There are two major components to Celeste Shell: the top bar and the launcher on the left-hand side of the screen. In the top bar, you can view the currently-running application's name, the current user, the time, and a few status indicators for settings and exiting the desktop. The launcher on the left displays favorite apps and provides the main entry point to access all apps. Customizing the desktop Click on the gear in the top bar to open the Settings pane for Celeste Shell. There are two sections in the settings: wallpaper selection, followed by the wallpaper display mode, which can be one of three options: Scaled to fit will try to fill the entire area of the display along the image's width and center it in the screen. Centered will center the image and fit the entire area of the display along the image's height. Stretch to fill will stretch the image to fit the display. Switching users To switch the current user that's logged in to the system, click on the current user's name in the top bar and then select the user to switch to. Pinning apps to the launcher The App Manager app provides access to pinning apps. Open the App Manager app, click on the app you want to pin from the left side, and then check the box labeled \"Pin to launcher\", next to the launch button. Available methods for developers Celeste Shell provides some static methods that developers can use to get information present in Celeste Shell easily: CelesteShell.get_all_applications() returns all of the classes and instanced apps available to Candella. CelesteShell.wallpapers() returns a list containing the names of the wallpapers available to Celeste Shell. CelesteShell.current_time() returns a string that represents the current time on the system.","title":"{HIDE} Celeste Shell"},{"location":"02-caberto-shell/#hide-celeste-shell","text":"The default desktop shell for Candella is Celeste (formerly known as Caberto Shell). Celeste's interface is mainly inspired from the Lomiri desktop environment and comes with per-user customizations. Warning Celeste is currently in a pre-release state and the documentation here may change as the project evolves.","title":"{HIDE} Celeste Shell"},{"location":"02-caberto-shell/#using-celeste-shell","text":"There are two major components to Celeste Shell: the top bar and the launcher on the left-hand side of the screen. In the top bar, you can view the currently-running application's name, the current user, the time, and a few status indicators for settings and exiting the desktop. The launcher on the left displays favorite apps and provides the main entry point to access all apps.","title":"Using Celeste Shell"},{"location":"02-caberto-shell/#customizing-the-desktop","text":"Click on the gear in the top bar to open the Settings pane for Celeste Shell. There are two sections in the settings: wallpaper selection, followed by the wallpaper display mode, which can be one of three options: Scaled to fit will try to fill the entire area of the display along the image's width and center it in the screen. Centered will center the image and fit the entire area of the display along the image's height. Stretch to fill will stretch the image to fit the display.","title":"Customizing the desktop"},{"location":"02-caberto-shell/#switching-users","text":"To switch the current user that's logged in to the system, click on the current user's name in the top bar and then select the user to switch to.","title":"Switching users"},{"location":"02-caberto-shell/#pinning-apps-to-the-launcher","text":"The App Manager app provides access to pinning apps. Open the App Manager app, click on the app you want to pin from the left side, and then check the box labeled \"Pin to launcher\", next to the launch button.","title":"Pinning apps to the launcher"},{"location":"02-caberto-shell/#available-methods-for-developers","text":"Celeste Shell provides some static methods that developers can use to get information present in Celeste Shell easily: CelesteShell.get_all_applications() returns all of the classes and instanced apps available to Candella. CelesteShell.wallpapers() returns a list containing the names of the wallpapers available to Celeste Shell. CelesteShell.current_time() returns a string that represents the current time on the system.","title":"Available methods for developers"},{"location":"02-celeste-shell/","text":"Celeste Shell The default desktop shell for Candella is Celeste (formerly known as Caberto Shell). Celeste's interface is mainly inspired from the Lomiri desktop environment and comes with per-user customizations. Using Celeste Shell There are two major components to Celeste Shell: the top bar and the launcher on the left-hand side of the screen. In the top bar, you can view the currently-running application's name, the current user, the time, and a few status indicators for settings and exiting the desktop. The launcher on the left displays favorite apps and provides the main entry point to access all apps. Customizing the desktop Click on the gear in the top bar to open the Settings pane for Celeste Shell. There are two sections in the settings: wallpaper selection, followed by the wallpaper display mode, which can be one of three options: Scaled to fit will try to fill the entire area of the display along the image's width and center it in the screen. Centered will center the image and fit the entire area of the display along the image's height. Stretch to fill will stretch the image to fit the display. Switching users To switch the current user that's logged in to the system, click on the current user's name in the top bar and then select the user to switch to. Important User-switching via Celeste Shell is available when there is more than one user present. Otherwise, the user's name will not appear. Pinning apps to the launcher The App Manager app provides access to pinning apps. Open the App Manager app, click on the app you want to pin from the left side, and then check the box labeled \"Pin to launcher\", next to the launch button. Available methods for developers Celeste Shell provides some static methods that developers can use to get information present in Celeste Shell easily: CelesteShell.get_all_applications() returns all of the classes and instanced apps available to Candella. CelesteShell.wallpapers() returns a list containing the names of the wallpapers available to Celeste Shell. CelesteShell.current_time() returns a string that represents the current time on the system.","title":"Celeste Shell"},{"location":"02-celeste-shell/#celeste-shell","text":"The default desktop shell for Candella is Celeste (formerly known as Caberto Shell). Celeste's interface is mainly inspired from the Lomiri desktop environment and comes with per-user customizations.","title":"Celeste Shell"},{"location":"02-celeste-shell/#using-celeste-shell","text":"There are two major components to Celeste Shell: the top bar and the launcher on the left-hand side of the screen. In the top bar, you can view the currently-running application's name, the current user, the time, and a few status indicators for settings and exiting the desktop. The launcher on the left displays favorite apps and provides the main entry point to access all apps.","title":"Using Celeste Shell"},{"location":"02-celeste-shell/#customizing-the-desktop","text":"Click on the gear in the top bar to open the Settings pane for Celeste Shell. There are two sections in the settings: wallpaper selection, followed by the wallpaper display mode, which can be one of three options: Scaled to fit will try to fill the entire area of the display along the image's width and center it in the screen. Centered will center the image and fit the entire area of the display along the image's height. Stretch to fill will stretch the image to fit the display.","title":"Customizing the desktop"},{"location":"02-celeste-shell/#switching-users","text":"To switch the current user that's logged in to the system, click on the current user's name in the top bar and then select the user to switch to. Important User-switching via Celeste Shell is available when there is more than one user present. Otherwise, the user's name will not appear.","title":"Switching users"},{"location":"02-celeste-shell/#pinning-apps-to-the-launcher","text":"The App Manager app provides access to pinning apps. Open the App Manager app, click on the app you want to pin from the left side, and then check the box labeled \"Pin to launcher\", next to the launch button.","title":"Pinning apps to the launcher"},{"location":"02-celeste-shell/#available-methods-for-developers","text":"Celeste Shell provides some static methods that developers can use to get information present in Celeste Shell easily: CelesteShell.get_all_applications() returns all of the classes and instanced apps available to Candella. CelesteShell.wallpapers() returns a list containing the names of the wallpapers available to Celeste Shell. CelesteShell.current_time() returns a string that represents the current time on the system.","title":"Available methods for developers"},{"location":"03-candella-app/","text":"Writing a Candella app Candella includes support for writing miniature apps that work within the Candella system. These apps sit on top of the AppKit framework for AliceOS (not to be confused with Apple's AppKit) and are backwards-compatible with AppKit APIs. Creating an app Candella apps are built in the same fashion as AliceOS apps by creating a directory with the aosapp extension in the Applications folder of a Ren'Py project. With the Candella SDK, you can run the following to interactively generate a project for you. The SDK will automatically create the structure and provide default icons for you. To do so, run the following: candella-sdk --action create --type application Alternatively, you can follow the instructions provided: If the Applications folder doesn't exist already, create it inside of the game directory. Create a folder with the structure YourAppName.aosapp inside of the Applications folder. Create a manifest file inside of the app folder using the manifest structure (see \"The manifest file\" ). Create the Resources/Iconset folders inside of the app directory. Add app icons for the following sizes in pixels (their names will be the corresponding size): 16, 24, 32, 48, 64, 128, 256, 512, 1024. Create a file with your app's name with the rpy extension. Use the template below to fill the contents of your app. # # AppName.rpy # Application # # (C) Year Author. # init offset = 10 init python: class AppName(CAApplication): def __init__(self): CAApplication.__init__(self, app_path=AS_APPS_DIR + \"AppName.aosapp/\") appname = AppName() The manifest file The manifest file contains information about your app, as well as what the app needs from Candella to run. The manifest file is located in the root of the app as manifest.json . Candella will automatically fill in the information of the app for you as the Ren'Py project initializes. Field What it does name A short name of your app. This can also be used as the command name. productName (Optional) A human-readable version of the app name. id An identifier for the app. It is recommended to use reverse domain notation. author The author of the app. It is recommended to use the Name <name@email.server> format. version The current version of the app. description A summary of what your app does. license The license your app falls under as an SPDX expression. permissions A list of strings containing what permissions your app requires. See permissions in the app manifest . requisites (Optional) A list of strings containing the names of the frameworks this app relies on. The following is an example manifest: { \"name\": \"textedit\", \"productName\": \"Text Editor\", \"id\": \"com.appleseed.text-editor\", \"author\": \"John Appleseed <john@appleseed.email>\", \"version\": \"12.0.0\", \"description\": \"A simple text editor for Candella.\", \"license\": \"GPL-3.0\", \"requires\": [\"file_system\"] } Manifest permissions The following is a list of the available permissions for apps and core services. Permission name What it grants file_system Requires access to the Candella \"file system\" notifications Requires access to NotificationKit to send notifications system_events Requires access to System Events manage_users Requires access to the accounts service to manage users virtual_platform Requires access to the MeteorVM platform App lifecycle In AliceOS, there are methods that exist for apps for launch and teardown. These methods are called when a stage of the app lifecycle will happen and when the stage has finished; for launch, this would be ASAppRepresentative.applicationWillLaunch and ASAppRepresentative.applicationDidLaunch , respectively. The same applies for when an app's termination cycle. Candella apps can still hook into these methods by defining similar methods: For launch, CAApplication.application_will_launch and CAApplication.application_did_launch . For teardown, CAApplication.application_will_terminate and CAApplication.application_did_terminate . Candella apps also have two new methods at their disposal that make calls to these methods: CAApplication.launch for launch stages in the app's lifecycle. CAApplication.terminate for termination stages. Whether you want to use the AliceOS-style approach or the new launch/terminate approach is up to you, but remember to keep your logic in a consistent order. If you decide to override the latter methods, be sure to emit the appropriate signals: In launch , emit_signal(\"application_launched\", name=self.get_name()) In terminate , emit_signal(\"application_terminated\") More information on AliceOS's app lifecycle can be found on the AliceOS documentation . Validating app frameworks If your Candella app requires frameworks and you want to check that those frameworks are available, you can add the requisites field to your manifest file. The requisites field takes a list of strings containing the framework names that are required for your app to run. Most apps by default will have a requisite list of [\"AppKit\", \"Observable\"] . Convenience methods Candella apps also include some methods to make gathering values a lot easier. These methods can be used to get the app's name or app icon; they are generally used in conjunction with services such as desktop shells. CAApplication.get_name() Returns the name of the app, or its bundle name. CAApplication.get_app_icon(size=16) Returns the path for a given icon size. App storage Apps can also store data for the currently logged-in user on the system; this data can be used to save preferences or other data that is necessary for app functions. App storage is handled by the AppStorage class and can be accessed for your app via CAApplication.data . Declare file system permissions Apps that utilize app storage must include the file_system permission in their app manifest in the permissions field. Apps will not be able to access app storage if this permission isn't declared or if the user has not granted the app permission to do so. There are three methods in AppStorage to help read and write data accordingly: AppStorage.get_entry(field, raise_falsy=False) will fetch the value for a field or return None if no value for the field was found. If raise_falsy is set to True , the method will instead raise an exception. AppStorage.set_entry(field, value) will write the value value into the specified field . AppStorage.commit() will commit all written changes to the current user's data file. Sensitive Information Do not store sensitive information in app storage unless you are using cryptography to encrypt the information. App storage is provided in the user's data file in a human-readable format and may be easily compromised if not encrypted properly. User interfaces User interfaces for Candella apps utilize ScreenKit, an AliceOS framework that uses Ren'Py screen language to construct consistent user interfaces that match the system. More information on generating user interfaces with ScreenKit can be found in the AliceOS documentation . Creating draggable windows It is recommended that, if possible, to give your app windows the ability to be dragged across the screen. This can be achieved by wrapping the window's content in a drag screen, supplying the following properties like in the example below: drag: drag_name \"NameOfScreenGoesHere\" drag_handle (0, 0, WindowMaxWidthHere, 64) xalign 0.5 yalign 0.5 ... drag_name should contain the name of the screen your app's window resides in drag_handle will set the draggability from the title bar. We recommend keeping the default values of 0, 0 for the X and Y values, as well as setting the last value (height) to 64px. The third element in the tuple should correspond to the width of the window. Other transform properties on the alignment must also appear in the draggable to set the default position. In most cases, this is in the center of the screen. Remember window modality rules Keep in mind your window's modality when making the window draggable. Windows in Candella should not be draggable if they are modal ( modal True in screen properties) unless there is a backdrop behind it. Leaving a window with draggable properties as a modal window may cause unexpected issues for players when trying to rearrange other windows. Sending notifications Candella offer two types of notifications: banners and alerts. Sending a banner or alert is easy with a simple method call. These method calls handle notification delegates and permission requests for you and will return the response provided, as well as emit it in a signal. CAAplication.send_alert(title, details, callback=Return('didDismissAlert')) Send an alert with respect to the user's settings. Arguments title (str): The title of the alert. details (str): The supporting text or details for the alert. callback (callable): The response callback function to run when dismissing the alert. Returns response (any): The response from the alert, if any. This response is also emitted as a signal. CAApplication.send_banner(title, supporting, callback=Return('didClickRespond')) Send a notification banner with respect to the user's settings. The banner request can be used in one of two ways: automatic, which utilizes the CANotificationBanner class to create a notification banner, and manual, which uses keyword arguments at call time to generate a banner on the fly. In most cases, it is recommended to use the automatic mode since the CANotificationBanner class offers more granular control over the appearance of the banner such as the action button text. Arguments mode (str): The means of sending the request. 'automatic' utilizes the CANotificationBanner class to create a banner, and 'manual' uses to the old style. By default, this method uses manual mode to ensure backwards-compatibility with AliceOS and older Candella versions. Keyword Arguments banner (CANotificationBanner): The banner object to send through this app. Required in automatic mode. title (str): The title of the banner. Required in manual mode. supporting (str): The supporting text for the banner. Required in manual mode. callback (callable): The response callback function to run when clicking the 'Respond' button. Required in manual mode. Returns response (any): The response from the banner request, if any. Add keyword arguments For Candella apps that use the manual mode or have supplied the contents of the banner as arguments, make sure that these are changed to keyword arguments, appropriately. Sending app signals Apps can send information to other services and even other apps. Candella apps adopt the Observable framework, which allows for signal emission. To emit a signal from your app, use the emit_signal method, followed by what you want to send. For instance, if you have an arcade shooter game ArcadeShooter and wanted to emit a signal to any receivers with an updated score: class ArcadeShooter(CAApplication): # ... def submit_score(self, score=0): self.score = score # Emit a signal with the updated score. # Apps and services that are listening to this # signal can access the score with kwargs[\"score\"]. self.emit_signal(\"score_submitted\", score=score) The following signals are emitted by default: Signal Arguments Purpose application_launched name=self.get_name() Indicates that the application launched successfully. application_launched_at_login name=self.get_name() Indicates that the application launched during the boot process successfully. application_terminated None Indicates that the application terminated successfully. banner_sent response=any Indicates that the application sent a banner notification request and received a response from the user. alert_sent response=any Indicates that the application sent an alert notification request and received a response from the user. CAApplication CAApplication is the primary class used to create Candella apps. It is an extension of the standard ASAppRepresentative class and aims to make app development simpler. This class provides extra utilities to simplify app development. Differences Between ASAppRepresentative Apps do not need to override class attributes to fill out app metadata. Instead, this is achieved with a manifest file, manifest.json. Notification requests are handled by methods that simplify calls. Grabbing icon sizes for an app is handled with a method. The description field for the app includes information regarding AliceOS compatibility. The license, product name, permissions, and description fields are present. This class contains methods for accessing user data via the Multiuser framework. This class inherits the CAObservable class, which will emit signals to services or apps that listen for it. Class Attributes description (str): The description for the app (same as bundleDescription). product_name (str): The human-readable name of the app. license (str): The license this app falls under. permissions (list): A list containing all of the permissions this app needs. data (AppStorage): An app storage object for this app, or None if the app doesn't need app storage.","title":"Writing a Candella app"},{"location":"03-candella-app/#writing-a-candella-app","text":"Candella includes support for writing miniature apps that work within the Candella system. These apps sit on top of the AppKit framework for AliceOS (not to be confused with Apple's AppKit) and are backwards-compatible with AppKit APIs.","title":"Writing a Candella app"},{"location":"03-candella-app/#creating-an-app","text":"Candella apps are built in the same fashion as AliceOS apps by creating a directory with the aosapp extension in the Applications folder of a Ren'Py project. With the Candella SDK, you can run the following to interactively generate a project for you. The SDK will automatically create the structure and provide default icons for you. To do so, run the following: candella-sdk --action create --type application Alternatively, you can follow the instructions provided: If the Applications folder doesn't exist already, create it inside of the game directory. Create a folder with the structure YourAppName.aosapp inside of the Applications folder. Create a manifest file inside of the app folder using the manifest structure (see \"The manifest file\" ). Create the Resources/Iconset folders inside of the app directory. Add app icons for the following sizes in pixels (their names will be the corresponding size): 16, 24, 32, 48, 64, 128, 256, 512, 1024. Create a file with your app's name with the rpy extension. Use the template below to fill the contents of your app. # # AppName.rpy # Application # # (C) Year Author. # init offset = 10 init python: class AppName(CAApplication): def __init__(self): CAApplication.__init__(self, app_path=AS_APPS_DIR + \"AppName.aosapp/\") appname = AppName()","title":"Creating an app"},{"location":"03-candella-app/#the-manifest-file","text":"The manifest file contains information about your app, as well as what the app needs from Candella to run. The manifest file is located in the root of the app as manifest.json . Candella will automatically fill in the information of the app for you as the Ren'Py project initializes. Field What it does name A short name of your app. This can also be used as the command name. productName (Optional) A human-readable version of the app name. id An identifier for the app. It is recommended to use reverse domain notation. author The author of the app. It is recommended to use the Name <name@email.server> format. version The current version of the app. description A summary of what your app does. license The license your app falls under as an SPDX expression. permissions A list of strings containing what permissions your app requires. See permissions in the app manifest . requisites (Optional) A list of strings containing the names of the frameworks this app relies on. The following is an example manifest: { \"name\": \"textedit\", \"productName\": \"Text Editor\", \"id\": \"com.appleseed.text-editor\", \"author\": \"John Appleseed <john@appleseed.email>\", \"version\": \"12.0.0\", \"description\": \"A simple text editor for Candella.\", \"license\": \"GPL-3.0\", \"requires\": [\"file_system\"] }","title":"The manifest file"},{"location":"03-candella-app/#manifest-permissions","text":"The following is a list of the available permissions for apps and core services. Permission name What it grants file_system Requires access to the Candella \"file system\" notifications Requires access to NotificationKit to send notifications system_events Requires access to System Events manage_users Requires access to the accounts service to manage users virtual_platform Requires access to the MeteorVM platform","title":"Manifest permissions"},{"location":"03-candella-app/#app-lifecycle","text":"In AliceOS, there are methods that exist for apps for launch and teardown. These methods are called when a stage of the app lifecycle will happen and when the stage has finished; for launch, this would be ASAppRepresentative.applicationWillLaunch and ASAppRepresentative.applicationDidLaunch , respectively. The same applies for when an app's termination cycle. Candella apps can still hook into these methods by defining similar methods: For launch, CAApplication.application_will_launch and CAApplication.application_did_launch . For teardown, CAApplication.application_will_terminate and CAApplication.application_did_terminate . Candella apps also have two new methods at their disposal that make calls to these methods: CAApplication.launch for launch stages in the app's lifecycle. CAApplication.terminate for termination stages. Whether you want to use the AliceOS-style approach or the new launch/terminate approach is up to you, but remember to keep your logic in a consistent order. If you decide to override the latter methods, be sure to emit the appropriate signals: In launch , emit_signal(\"application_launched\", name=self.get_name()) In terminate , emit_signal(\"application_terminated\") More information on AliceOS's app lifecycle can be found on the AliceOS documentation .","title":"App lifecycle"},{"location":"03-candella-app/#validating-app-frameworks","text":"If your Candella app requires frameworks and you want to check that those frameworks are available, you can add the requisites field to your manifest file. The requisites field takes a list of strings containing the framework names that are required for your app to run. Most apps by default will have a requisite list of [\"AppKit\", \"Observable\"] .","title":"Validating app frameworks"},{"location":"03-candella-app/#convenience-methods","text":"Candella apps also include some methods to make gathering values a lot easier. These methods can be used to get the app's name or app icon; they are generally used in conjunction with services such as desktop shells.","title":"Convenience methods"},{"location":"03-candella-app/#caapplicationget_name","text":"Returns the name of the app, or its bundle name.","title":"CAApplication.get_name()"},{"location":"03-candella-app/#caapplicationget_app_iconsize16","text":"Returns the path for a given icon size.","title":"CAApplication.get_app_icon(size=16)"},{"location":"03-candella-app/#app-storage","text":"Apps can also store data for the currently logged-in user on the system; this data can be used to save preferences or other data that is necessary for app functions. App storage is handled by the AppStorage class and can be accessed for your app via CAApplication.data . Declare file system permissions Apps that utilize app storage must include the file_system permission in their app manifest in the permissions field. Apps will not be able to access app storage if this permission isn't declared or if the user has not granted the app permission to do so. There are three methods in AppStorage to help read and write data accordingly: AppStorage.get_entry(field, raise_falsy=False) will fetch the value for a field or return None if no value for the field was found. If raise_falsy is set to True , the method will instead raise an exception. AppStorage.set_entry(field, value) will write the value value into the specified field . AppStorage.commit() will commit all written changes to the current user's data file. Sensitive Information Do not store sensitive information in app storage unless you are using cryptography to encrypt the information. App storage is provided in the user's data file in a human-readable format and may be easily compromised if not encrypted properly.","title":"App storage"},{"location":"03-candella-app/#user-interfaces","text":"User interfaces for Candella apps utilize ScreenKit, an AliceOS framework that uses Ren'Py screen language to construct consistent user interfaces that match the system. More information on generating user interfaces with ScreenKit can be found in the AliceOS documentation .","title":"User interfaces"},{"location":"03-candella-app/#creating-draggable-windows","text":"It is recommended that, if possible, to give your app windows the ability to be dragged across the screen. This can be achieved by wrapping the window's content in a drag screen, supplying the following properties like in the example below: drag: drag_name \"NameOfScreenGoesHere\" drag_handle (0, 0, WindowMaxWidthHere, 64) xalign 0.5 yalign 0.5 ... drag_name should contain the name of the screen your app's window resides in drag_handle will set the draggability from the title bar. We recommend keeping the default values of 0, 0 for the X and Y values, as well as setting the last value (height) to 64px. The third element in the tuple should correspond to the width of the window. Other transform properties on the alignment must also appear in the draggable to set the default position. In most cases, this is in the center of the screen. Remember window modality rules Keep in mind your window's modality when making the window draggable. Windows in Candella should not be draggable if they are modal ( modal True in screen properties) unless there is a backdrop behind it. Leaving a window with draggable properties as a modal window may cause unexpected issues for players when trying to rearrange other windows.","title":"Creating draggable windows"},{"location":"03-candella-app/#sending-notifications","text":"Candella offer two types of notifications: banners and alerts. Sending a banner or alert is easy with a simple method call. These method calls handle notification delegates and permission requests for you and will return the response provided, as well as emit it in a signal.","title":"Sending notifications"},{"location":"03-candella-app/#caaplicationsend_alerttitle-details-callbackreturndiddismissalert","text":"Send an alert with respect to the user's settings. Arguments title (str): The title of the alert. details (str): The supporting text or details for the alert. callback (callable): The response callback function to run when dismissing the alert. Returns response (any): The response from the alert, if any. This response is also emitted as a signal.","title":"CAAplication.send_alert(title, details, callback=Return('didDismissAlert'))"},{"location":"03-candella-app/#caapplicationsend_bannertitle-supporting-callbackreturndidclickrespond","text":"Send a notification banner with respect to the user's settings. The banner request can be used in one of two ways: automatic, which utilizes the CANotificationBanner class to create a notification banner, and manual, which uses keyword arguments at call time to generate a banner on the fly. In most cases, it is recommended to use the automatic mode since the CANotificationBanner class offers more granular control over the appearance of the banner such as the action button text. Arguments mode (str): The means of sending the request. 'automatic' utilizes the CANotificationBanner class to create a banner, and 'manual' uses to the old style. By default, this method uses manual mode to ensure backwards-compatibility with AliceOS and older Candella versions. Keyword Arguments banner (CANotificationBanner): The banner object to send through this app. Required in automatic mode. title (str): The title of the banner. Required in manual mode. supporting (str): The supporting text for the banner. Required in manual mode. callback (callable): The response callback function to run when clicking the 'Respond' button. Required in manual mode. Returns response (any): The response from the banner request, if any. Add keyword arguments For Candella apps that use the manual mode or have supplied the contents of the banner as arguments, make sure that these are changed to keyword arguments, appropriately.","title":"CAApplication.send_banner(title, supporting, callback=Return('didClickRespond'))"},{"location":"03-candella-app/#sending-app-signals","text":"Apps can send information to other services and even other apps. Candella apps adopt the Observable framework, which allows for signal emission. To emit a signal from your app, use the emit_signal method, followed by what you want to send. For instance, if you have an arcade shooter game ArcadeShooter and wanted to emit a signal to any receivers with an updated score: class ArcadeShooter(CAApplication): # ... def submit_score(self, score=0): self.score = score # Emit a signal with the updated score. # Apps and services that are listening to this # signal can access the score with kwargs[\"score\"]. self.emit_signal(\"score_submitted\", score=score) The following signals are emitted by default: Signal Arguments Purpose application_launched name=self.get_name() Indicates that the application launched successfully. application_launched_at_login name=self.get_name() Indicates that the application launched during the boot process successfully. application_terminated None Indicates that the application terminated successfully. banner_sent response=any Indicates that the application sent a banner notification request and received a response from the user. alert_sent response=any Indicates that the application sent an alert notification request and received a response from the user.","title":"Sending app signals"},{"location":"03-candella-app/#caapplication","text":"CAApplication is the primary class used to create Candella apps. It is an extension of the standard ASAppRepresentative class and aims to make app development simpler. This class provides extra utilities to simplify app development.","title":"CAApplication"},{"location":"03-candella-app/#differences-between-asapprepresentative","text":"Apps do not need to override class attributes to fill out app metadata. Instead, this is achieved with a manifest file, manifest.json. Notification requests are handled by methods that simplify calls. Grabbing icon sizes for an app is handled with a method. The description field for the app includes information regarding AliceOS compatibility. The license, product name, permissions, and description fields are present. This class contains methods for accessing user data via the Multiuser framework. This class inherits the CAObservable class, which will emit signals to services or apps that listen for it.","title":"Differences Between ASAppRepresentative"},{"location":"03-candella-app/#class-attributes","text":"description (str): The description for the app (same as bundleDescription). product_name (str): The human-readable name of the app. license (str): The license this app falls under. permissions (list): A list containing all of the permissions this app needs. data (AppStorage): An app storage object for this app, or None if the app doesn't need app storage.","title":"Class Attributes"},{"location":"04-observable/","text":"Observable Framework Observable is a Candella framework designed to add observability to classes, similar to what's offered in languages like Java. What uses Observable? Candella uses Observable in a few places: In AppKit , all apps inherit the CAObservable class and can emit signals to observers. In ServiceKit , core services inherit CAObservable and emit signals to observers. In Celeste Shell , the service listens for signal emissions and acts as an observer with a callback method. Logic To use Observable, you need to have two things: an observable item that subclasses from CAObservable , and a callback method that listens for signals when they're emitted. Let's say that we're making some sort of logger that listens for when apps are opened. We can do the following to accomplish this: def callback(*args, **kwargs): if \"application_launched\" not in args: return appname = kwargs[\"name\"] if \"name\" in kwargs else \"Application\" print(appname + \" was launched!\") class App(CAObservable): def __init__(self): CAObservable.__init__(self) self.register_event(callback) def open(self): self.emit_signal(\"application_launched\", self.__class__.__name__) When the open method on the App class is called, the callback function will receive that update and trigger accordingly. CAObservable A class that can be observed by methods. register_event(callable) Register an event to listen to this observable class. Arguments callable (callable): The method that will listen for changes. emit_signal(*args, **kwargs) Emit a signal to all known observers of this class. The signal's identifier should be passed in args and any additional data should be passed as a keyword argument in kwargs .","title":"Observable Framework"},{"location":"04-observable/#observable-framework","text":"Observable is a Candella framework designed to add observability to classes, similar to what's offered in languages like Java.","title":"Observable Framework"},{"location":"04-observable/#what-uses-observable","text":"Candella uses Observable in a few places: In AppKit , all apps inherit the CAObservable class and can emit signals to observers. In ServiceKit , core services inherit CAObservable and emit signals to observers. In Celeste Shell , the service listens for signal emissions and acts as an observer with a callback method.","title":"What uses Observable?"},{"location":"04-observable/#logic","text":"To use Observable, you need to have two things: an observable item that subclasses from CAObservable , and a callback method that listens for signals when they're emitted. Let's say that we're making some sort of logger that listens for when apps are opened. We can do the following to accomplish this: def callback(*args, **kwargs): if \"application_launched\" not in args: return appname = kwargs[\"name\"] if \"name\" in kwargs else \"Application\" print(appname + \" was launched!\") class App(CAObservable): def __init__(self): CAObservable.__init__(self) self.register_event(callback) def open(self): self.emit_signal(\"application_launched\", self.__class__.__name__) When the open method on the App class is called, the callback function will receive that update and trigger accordingly.","title":"Logic"},{"location":"04-observable/#caobservable","text":"A class that can be observed by methods.","title":"CAObservable"},{"location":"04-observable/#register_eventcallable","text":"Register an event to listen to this observable class. Arguments callable (callable): The method that will listen for changes.","title":"register_event(callable)"},{"location":"04-observable/#emit_signalargs-kwargs","text":"Emit a signal to all known observers of this class. The signal's identifier should be passed in args and any additional data should be passed as a keyword argument in kwargs .","title":"emit_signal(*args, **kwargs)"},{"location":"05-multiuser/","text":"Multiuser Framework Multi-user support in Candella is provided by the Multiuser framework. This framework adds the necessary classes and utilities to create and manage multiple users, as well as manage data for specific users. What is a Candella user? A user is defined by a username and is represented as the CAUser data class. In most cases, developers will not need to create an instance of this class as core services and applications will provide this automatically. CAUser.username contains the username of the user. Usernames must be in lowercase with no spaces or special characters. CAUser.display_name contains the user-facing display name for the user. This display name is used by core services such as Celeste Shell to display the user's name. By default, this name defaults to the username. CAUser provides methods for checking equality and string representation. The userland folder Each user gets a corresponding file in the .causerland directory. This directory is located in the save directory of the Ren'Py project. For instance, if Candella were installed in Doki Doki Literature Club! , the userland folder is located at the following path: %AppData%\\RenPy\\DDLC\\.causerland # Windows ~/Library/RenPy/DDLC/.causerland # macOS ~/.renpy/DDLC/.causerland # Linux Users and app/service developers typically don't need to worry about the user file as classes exists for managing data in the userland folder. Reading/writing data for the current user Apps and services provide their own means of accessing sandboxed data. These classes ensure that the app or service can locally access only their data. App/service data is registered under its bundle ID. AppStorage For Candella apps, the AppStorage class is used to manage data. More information using AppStorage can be found in the documentation for creating Candella apps . ServiceStorage Likewise, core services in Candella utilize the ServiceStorage class. Like AppStorage , data is separated by bundle ID and is accessible via the data field of the CACoreService class. There are three methods available for managing service data: ServiceStorage.get_entry(field, raise_falsy=False) will fetch the value for a field or return None if no value for the field was found. If raise_falsy is set to True , the method will instead raise an exception. ServiceStorage.set_entry(field, value) will write the value value into the specified field . ServiceStorage.commit() will commit all written changes to the current user's data file. Sensitive Information Do not store sensitive information in service storage unless you are using cryptography to encrypt the information. Service storage is provided in the user's data file in a human-readable format and may be easily compromised if not encrypted properly. Global scope access There may be instances where you need to access application data outside of the app class. There are two static methods in the CAUserData class to handle this: CAUserData.get_current_user_data(bundle_id) Returns the application data for the current user. Arguments bundle_id (str): The app's bundle ID. Returns app_data (dict): The user data for the specified app as a dictionary. If no data was found for the app, an empty dictionary will be returned. Raises If the app doesn't have permissions to open the data, CAUserDataPermissionError is raised. If the user file doesn't exist, FileNotFoundError is raised. Otherwise, any other exceptions from file opening and parsing may be thrown. CAUserData.write_data_to_current_user(bundle_id, data={}) Writes the specified app data to the current user's file. Arguments bundle_id (str): The app's bundle ID data (dict): The data to write to the file for that bundle ID. Raises If the app doesn't have permissions to write the data, CAUserDataPermissionError is raised. If the user file doesn't exist, FileNotFoundError is raised. Otherwise, any other exceptions from file opening and writing may be thrown.","title":"Multiuser Framework"},{"location":"05-multiuser/#multiuser-framework","text":"Multi-user support in Candella is provided by the Multiuser framework. This framework adds the necessary classes and utilities to create and manage multiple users, as well as manage data for specific users.","title":"Multiuser Framework"},{"location":"05-multiuser/#what-is-a-candella-user","text":"A user is defined by a username and is represented as the CAUser data class. In most cases, developers will not need to create an instance of this class as core services and applications will provide this automatically. CAUser.username contains the username of the user. Usernames must be in lowercase with no spaces or special characters. CAUser.display_name contains the user-facing display name for the user. This display name is used by core services such as Celeste Shell to display the user's name. By default, this name defaults to the username. CAUser provides methods for checking equality and string representation.","title":"What is a Candella user?"},{"location":"05-multiuser/#the-userland-folder","text":"Each user gets a corresponding file in the .causerland directory. This directory is located in the save directory of the Ren'Py project. For instance, if Candella were installed in Doki Doki Literature Club! , the userland folder is located at the following path: %AppData%\\RenPy\\DDLC\\.causerland # Windows ~/Library/RenPy/DDLC/.causerland # macOS ~/.renpy/DDLC/.causerland # Linux Users and app/service developers typically don't need to worry about the user file as classes exists for managing data in the userland folder.","title":"The userland folder"},{"location":"05-multiuser/#readingwriting-data-for-the-current-user","text":"Apps and services provide their own means of accessing sandboxed data. These classes ensure that the app or service can locally access only their data. App/service data is registered under its bundle ID.","title":"Reading/writing data for the current user"},{"location":"05-multiuser/#appstorage","text":"For Candella apps, the AppStorage class is used to manage data. More information using AppStorage can be found in the documentation for creating Candella apps .","title":"AppStorage"},{"location":"05-multiuser/#servicestorage","text":"Likewise, core services in Candella utilize the ServiceStorage class. Like AppStorage , data is separated by bundle ID and is accessible via the data field of the CACoreService class. There are three methods available for managing service data: ServiceStorage.get_entry(field, raise_falsy=False) will fetch the value for a field or return None if no value for the field was found. If raise_falsy is set to True , the method will instead raise an exception. ServiceStorage.set_entry(field, value) will write the value value into the specified field . ServiceStorage.commit() will commit all written changes to the current user's data file. Sensitive Information Do not store sensitive information in service storage unless you are using cryptography to encrypt the information. Service storage is provided in the user's data file in a human-readable format and may be easily compromised if not encrypted properly.","title":"ServiceStorage"},{"location":"05-multiuser/#global-scope-access","text":"There may be instances where you need to access application data outside of the app class. There are two static methods in the CAUserData class to handle this:","title":"Global scope access"},{"location":"05-multiuser/#causerdataget_current_user_databundle_id","text":"Returns the application data for the current user. Arguments bundle_id (str): The app's bundle ID. Returns app_data (dict): The user data for the specified app as a dictionary. If no data was found for the app, an empty dictionary will be returned. Raises If the app doesn't have permissions to open the data, CAUserDataPermissionError is raised. If the user file doesn't exist, FileNotFoundError is raised. Otherwise, any other exceptions from file opening and parsing may be thrown.","title":"CAUserData.get_current_user_data(bundle_id)"},{"location":"05-multiuser/#causerdatawrite_data_to_current_userbundle_id-data","text":"Writes the specified app data to the current user's file. Arguments bundle_id (str): The app's bundle ID data (dict): The data to write to the file for that bundle ID. Raises If the app doesn't have permissions to write the data, CAUserDataPermissionError is raised. If the user file doesn't exist, FileNotFoundError is raised. Otherwise, any other exceptions from file opening and writing may be thrown.","title":"CAUserData.write_data_to_current_user(bundle_id, data={})"},{"location":"06-accounts-service/","text":"Accounts Service The Accounts Service for Candella extends the functionality of the Multiuser framework and adds support for managing users in a way that lets other services handle this functionality. This service defines a single class, CAAccountsService , to manage users efficiently. Backwards Compatibility with AliceOS To maintain backwards compatibility with AliceOS, the username of the currently logged-in user is set in AliceOS's persistent.playername . This field is commonly used by services and apps for the current player, and it also defines the player's name in games like Doki Doki Literature Club! . Viewing information about the userspace Currently, there are two static methods available to get information about the userspace: CAAccountsService.get_logged_in_user() returns a CAUser object that contains the information about the currently logged-in user. CAAccountsService.get_all_users() returns a list of CAUser objects that contain information about all users known to Candella in the userspace. Managing users While accessing user information is static and does not require instancing, CAAccountsService should be instanced in the service or app that requests these features to manage data more efficiently. Including an instance in your service or app ensures that no other services are using that app's copy, and it helps reduce variables in Ren'Py's store. Declare user permissions For an app or service to manage users, the manage_users permission must be enabled for that service or app. This can be defined in the permissions field in an app's manifest and the requisites field in a service's manifest, respectively. To instantiate an instance of the account manager, you'll need to pass in the service or app instance with the manage_users permission: class SampleCoreService(CACoreService): def __init__(self): CACoreService.__init__(self) self._accounts = CAAccountsService(self) add_user(self, username, pretty_name=None) Creates the user file for a given user and adds it to the user list. Arguments username (str): The username for the new user. pretty_name (str): The display name for the new user. change_current_user(self, username) Change the currently logged-in user. Arguments username (str): The username of the user to switch to. remove_user(self, username) Removes the specified user. Arguments username (str): The username of the user to remove.","title":"Accounts Service"},{"location":"06-accounts-service/#accounts-service","text":"The Accounts Service for Candella extends the functionality of the Multiuser framework and adds support for managing users in a way that lets other services handle this functionality. This service defines a single class, CAAccountsService , to manage users efficiently. Backwards Compatibility with AliceOS To maintain backwards compatibility with AliceOS, the username of the currently logged-in user is set in AliceOS's persistent.playername . This field is commonly used by services and apps for the current player, and it also defines the player's name in games like Doki Doki Literature Club! .","title":"Accounts Service"},{"location":"06-accounts-service/#viewing-information-about-the-userspace","text":"Currently, there are two static methods available to get information about the userspace: CAAccountsService.get_logged_in_user() returns a CAUser object that contains the information about the currently logged-in user. CAAccountsService.get_all_users() returns a list of CAUser objects that contain information about all users known to Candella in the userspace.","title":"Viewing information about the userspace"},{"location":"06-accounts-service/#managing-users","text":"While accessing user information is static and does not require instancing, CAAccountsService should be instanced in the service or app that requests these features to manage data more efficiently. Including an instance in your service or app ensures that no other services are using that app's copy, and it helps reduce variables in Ren'Py's store. Declare user permissions For an app or service to manage users, the manage_users permission must be enabled for that service or app. This can be defined in the permissions field in an app's manifest and the requisites field in a service's manifest, respectively. To instantiate an instance of the account manager, you'll need to pass in the service or app instance with the manage_users permission: class SampleCoreService(CACoreService): def __init__(self): CACoreService.__init__(self) self._accounts = CAAccountsService(self)","title":"Managing users"},{"location":"06-accounts-service/#add_userself-username-pretty_namenone","text":"Creates the user file for a given user and adds it to the user list. Arguments username (str): The username for the new user. pretty_name (str): The display name for the new user.","title":"add_user(self, username, pretty_name=None)"},{"location":"06-accounts-service/#change_current_userself-username","text":"Change the currently logged-in user. Arguments username (str): The username of the user to switch to.","title":"change_current_user(self, username)"},{"location":"06-accounts-service/#remove_userself-username","text":"Removes the specified user. Arguments username (str): The username of the user to remove.","title":"remove_user(self, username)"},{"location":"07-roland-boot/","text":"Roland Boot Manager Candella utilizes the Roland Boot Manager to start and shut down Candella and its apps/services. Roland allows for a modular approach to booting/shutting down services and apps by letting developers select if a boot screen should be displayed, what screen to load during boot, how long to display it for if Roland finishes. The same applies for shutdown. Loading the boot manager Ideally, the boot manager's boot sequence should be loaded into Ren'Py's splashscreen label: label splashscreen: $ roland.boot() return There are two additional parameters that can be passed into the boot function: loader (str): The name of the Ren'Py screen to display during boot. By default, this is set to None , thus not displaying a screen. minimum_load_time (float): The minimum amount of seconds the boot screen should be displayed if the boot sequence finishes too quickly. By default, this is set to 0.0 . run_setup (bool): Whether to look for a setup assistant and run it if setup is incomplete or hasn't been executed before. By default, this is set to True . Default boot screens The Roland Boot Manager comes with a few loading screens by default: Preview Loader name Description RolandGraphicalLoader A graphical loader with the game's window icon, if the file is present. Otherwise, the Candella logo is displayed. RolandGraphicalLogomarkLoader A graphical loader that displays the Candella logomark, as well as a row of icons at the bottom for all of the core services installed. RolandTextLoader A text-based loader that displays the contents of the Candella log file. Creating a custom loading screen You can create a standard Ren'Py screen with the bootloader tag and a zorder of 200 to be displayed by the boot manager. An example is provided below: screen SampleLoader(): zorder 200 tag bootloader modal False add \"#000000\" vbox: align (0.5, 0.5) text \"Loading the system...\": xalign 0.5 text_align 0.5 Important The loading screen should not have any required parameters. The boot manager will not be able to supply arguments to get passed into the loading screen. Shutting down Candella with the boot manager Like with the boot method in the splashscreen label, the shutdown method should be inserted in the quit label: label quit: $ roland.shutdown() return Like the boot method, there is an additional optional argument, loader , which displays a Ren'Py screen during the shutdown process; however, the screen does not include a minimum loading time unlike the boot sequence. By default, this value is set to None , indicating that no screen will be displayed.","title":"Roland Boot Manager"},{"location":"07-roland-boot/#roland-boot-manager","text":"Candella utilizes the Roland Boot Manager to start and shut down Candella and its apps/services. Roland allows for a modular approach to booting/shutting down services and apps by letting developers select if a boot screen should be displayed, what screen to load during boot, how long to display it for if Roland finishes. The same applies for shutdown.","title":"Roland Boot Manager"},{"location":"07-roland-boot/#loading-the-boot-manager","text":"Ideally, the boot manager's boot sequence should be loaded into Ren'Py's splashscreen label: label splashscreen: $ roland.boot() return There are two additional parameters that can be passed into the boot function: loader (str): The name of the Ren'Py screen to display during boot. By default, this is set to None , thus not displaying a screen. minimum_load_time (float): The minimum amount of seconds the boot screen should be displayed if the boot sequence finishes too quickly. By default, this is set to 0.0 . run_setup (bool): Whether to look for a setup assistant and run it if setup is incomplete or hasn't been executed before. By default, this is set to True .","title":"Loading the boot manager"},{"location":"07-roland-boot/#default-boot-screens","text":"The Roland Boot Manager comes with a few loading screens by default: Preview Loader name Description RolandGraphicalLoader A graphical loader with the game's window icon, if the file is present. Otherwise, the Candella logo is displayed. RolandGraphicalLogomarkLoader A graphical loader that displays the Candella logomark, as well as a row of icons at the bottom for all of the core services installed. RolandTextLoader A text-based loader that displays the contents of the Candella log file.","title":"Default boot screens"},{"location":"07-roland-boot/#creating-a-custom-loading-screen","text":"You can create a standard Ren'Py screen with the bootloader tag and a zorder of 200 to be displayed by the boot manager. An example is provided below: screen SampleLoader(): zorder 200 tag bootloader modal False add \"#000000\" vbox: align (0.5, 0.5) text \"Loading the system...\": xalign 0.5 text_align 0.5 Important The loading screen should not have any required parameters. The boot manager will not be able to supply arguments to get passed into the loading screen.","title":"Creating a custom loading screen"},{"location":"07-roland-boot/#shutting-down-candella-with-the-boot-manager","text":"Like with the boot method in the splashscreen label, the shutdown method should be inserted in the quit label: label quit: $ roland.shutdown() return Like the boot method, there is an additional optional argument, loader , which displays a Ren'Py screen during the shutdown process; however, the screen does not include a minimum loading time unlike the boot sequence. By default, this value is set to None , indicating that no screen will be displayed.","title":"Shutting down Candella with the boot manager"},{"location":"08-thorax-setup/","text":"Thorax Setup Candella utilizes a new setup assistant called Thorax . Thorax is a modern, modular implementation for setup assistants in Candella and defines steps with a simple JSON file as a script. Running the default setup In most cases, you'll want to use the default set of setup instructions, which lets users know about Candella, set up a new user, and finish setup (this set is equivalent to AliceOS's Express Mode in their setup assistant). The Roland Boot Manager will automatically run Thorax with the default steps when it has detected that the system hasn't been set up, or the assistant needs to run again. To use the default set and run setup at any time, call the launch method, without any additional arguments: setup.launch() Writing a custom setup script If you want to perform additional actions with the Thorax setup assistant, you can create your own setup script. Thorax uses a JSON file with a list of setup objects to perform steps accordingly. A step is defined by the following keys: name : The name of the step to display in the top bar of the screen. detail : A paragraph that provides a description of the step or instructions for the user to follow. keyboard_input : Whether the user needs to type something into an input field to process the step. callback : (Optional) The name of the callback function to execute when the user presses 'Next' or Enter/Return on their keyboard. The callback must accept a single argument. By default, Thorax includes two callbacks: create_user and complete . An example setup script can be seen here: [ { \"name\": \"Create a user account\", \"detail\": \"Enter the name of the user you wish to create for this system.\", \"keyboard_input\": true, \"callback\": \"create_user\" } ] To run the setup assistant with these custom steps, call launch and pass the path to the JSON file as an argument: setup.launch(\"path/to/setup_script.json\") Adding custom callbacks You may need to write a custom callback if you wish to perform another action besides creating a user and acknowledging that the setup assistant completed. To do this, create a function that accepts a single argument and use setup.add_setup_callback to add it to the setup callback registry: def set_machine_name(name): persistent.AS_MACHINE_NAME = name setup.add_setup_callback(\"set_machine_name\", set_machine_name) add_setup_callback requires two arguments: name (str): The name of the callback as defined in the setup script callback (callable): The function to run when the step completes","title":"Thorax Setup"},{"location":"08-thorax-setup/#thorax-setup","text":"Candella utilizes a new setup assistant called Thorax . Thorax is a modern, modular implementation for setup assistants in Candella and defines steps with a simple JSON file as a script.","title":"Thorax Setup"},{"location":"08-thorax-setup/#running-the-default-setup","text":"In most cases, you'll want to use the default set of setup instructions, which lets users know about Candella, set up a new user, and finish setup (this set is equivalent to AliceOS's Express Mode in their setup assistant). The Roland Boot Manager will automatically run Thorax with the default steps when it has detected that the system hasn't been set up, or the assistant needs to run again. To use the default set and run setup at any time, call the launch method, without any additional arguments: setup.launch()","title":"Running the default setup"},{"location":"08-thorax-setup/#writing-a-custom-setup-script","text":"If you want to perform additional actions with the Thorax setup assistant, you can create your own setup script. Thorax uses a JSON file with a list of setup objects to perform steps accordingly. A step is defined by the following keys: name : The name of the step to display in the top bar of the screen. detail : A paragraph that provides a description of the step or instructions for the user to follow. keyboard_input : Whether the user needs to type something into an input field to process the step. callback : (Optional) The name of the callback function to execute when the user presses 'Next' or Enter/Return on their keyboard. The callback must accept a single argument. By default, Thorax includes two callbacks: create_user and complete . An example setup script can be seen here: [ { \"name\": \"Create a user account\", \"detail\": \"Enter the name of the user you wish to create for this system.\", \"keyboard_input\": true, \"callback\": \"create_user\" } ] To run the setup assistant with these custom steps, call launch and pass the path to the JSON file as an argument: setup.launch(\"path/to/setup_script.json\")","title":"Writing a custom setup script"},{"location":"08-thorax-setup/#adding-custom-callbacks","text":"You may need to write a custom callback if you wish to perform another action besides creating a user and acknowledging that the setup assistant completed. To do this, create a function that accepts a single argument and use setup.add_setup_callback to add it to the setup callback registry: def set_machine_name(name): persistent.AS_MACHINE_NAME = name setup.add_setup_callback(\"set_machine_name\", set_machine_name) add_setup_callback requires two arguments: name (str): The name of the callback as defined in the setup script callback (callable): The function to run when the step completes","title":"Adding custom callbacks"},{"location":"09-glossary/","text":"Glossary The Glossary app for Candella provides a fast and easy way for visual novel developers to define terms used in the game and an intuitive way for users to discover these terms. Creating a glossary The glossary file used in Candella is a JSON file with a single root-level key, dictionary . In there, you can define additional words with their respective definitions as a JSON object: { \"dictionary\": { \"changeling\": \"A creature that has the ability to transform into another.\", \"hTML\": \"Short for hyper-text markup langage, the language that is used to create web pages on the internet.\" } } If you're including an acronym as a term or need to include uppercase letters, make the first letter lowercase, then use uppercase for the rest. To add spaces to indicate a phrase, use an underscore. Displaying the glossary To display the glossary window with a custom glossary programmatically, use renpy.show_screen : renpy.show_screen( \"GlossaryAppUIView\", glossary=glossary.load_glossary(\"path/to/glossary.json\") ) If no arguments are passed in load_glossary , the app will default to the built-in glossary. Overriding the default glossary If you need to override the default glossary with your own, you can change the default_glossary property of the glossary instance. This may be used in scenarios where you want the Glossary app to open your default glossary when the user opens it in a launcher like Celeste Shell. glossary.default_glossary = \"path/to/default_glossary.json\"","title":"Glossary"},{"location":"09-glossary/#glossary","text":"The Glossary app for Candella provides a fast and easy way for visual novel developers to define terms used in the game and an intuitive way for users to discover these terms.","title":"Glossary"},{"location":"09-glossary/#creating-a-glossary","text":"The glossary file used in Candella is a JSON file with a single root-level key, dictionary . In there, you can define additional words with their respective definitions as a JSON object: { \"dictionary\": { \"changeling\": \"A creature that has the ability to transform into another.\", \"hTML\": \"Short for hyper-text markup langage, the language that is used to create web pages on the internet.\" } } If you're including an acronym as a term or need to include uppercase letters, make the first letter lowercase, then use uppercase for the rest. To add spaces to indicate a phrase, use an underscore.","title":"Creating a glossary"},{"location":"09-glossary/#displaying-the-glossary","text":"To display the glossary window with a custom glossary programmatically, use renpy.show_screen : renpy.show_screen( \"GlossaryAppUIView\", glossary=glossary.load_glossary(\"path/to/glossary.json\") ) If no arguments are passed in load_glossary , the app will default to the built-in glossary.","title":"Displaying the glossary"},{"location":"09-glossary/#overriding-the-default-glossary","text":"If you need to override the default glossary with your own, you can change the default_glossary property of the glossary instance. This may be used in scenarios where you want the Glossary app to open your default glossary when the user opens it in a launcher like Celeste Shell. glossary.default_glossary = \"path/to/default_glossary.json\"","title":"Overriding the default glossary"},{"location":"10-candella-service/","text":"Writing core services In addition to writing custom apps, Candella offers support for writing custom core services that other apps can rely on. Core services are handled by the CACoreService class and function similarly to Candella apps. Core services also inherit the properties of CAObservable , allowing it to emit signals to observers. Creating a core service The recommended way of creating a core service from scratch is to use the Candella SDK and follow the interactive prompts: candella-sdk --action create --type service Likewise, you can also follow the instructions below to make a core service manually: Create a folder with the structure YourAppName.aosapp inside of the System/CoreServices folder. Create a manifest file inside of the service folder using the manifest structure (see \"The manifest file\" ). Create the Resources/Iconset folders inside of the service directory. Add service icons for the following sizes in pixels (their names will be the corresponding size): 16, 24, 32, 48, 64, 128, 256, 512, 1024. Create a file with your service's name with the rpy extension. Use the template below to fill the contents of your service. # # ServiceName.rpy # Service Name # # (C) Year Author. # init offset = 5 init python: class Service(CACoreService): \"\"\"Service description\"\"\" def __init__(self): CACoreService.__init__( self, AS_CORESERVICES_DIR + \"ServiceName.aoscservice/\" ) # Initialize your core service here. # Initialize the service outside of the class. service = Service() The manifest file Like Candella apps, core services also include a manifest file that defines the service, as well as its permissions and requisites. This is also located in the root of the service folder and should be named manifest.json . Field What it does name A short name of your service. id An identifier for the service. It is recommended to use reverse domain notation. author The author of the service. It is recommended to use the Name <name@email.server> format. version The current version of the service. description A summary of what your service does. license The license your service falls under as an SPDX expression. permissions A list of strings containing what permissions your service requires. See permissions in the app manifest . requisites (Optional) A list of strings containing the names of the frameworks this service relies on. Unrestricted access Core services typically have unrestricted access to resources, unlike Candella apps, when declared in the manifest. Ensure that you declare only the permissions you need and that you use those resource wisely. Validating service requisites Core services that depend on requisite frameworks should be declared in the app's manifest under the requisites field. At initialization time, the service will determine whether or not the frameworks are present. Core service lifecycle Like Candella apps, core services have a lifecycle based on the structure of AliceOS core services. These methods are called when a stage of the service lifecycle will happen and when the stage has finished; for launch, this would be ASCoreServiceRepresentative.serviceWillLaunch and ASCoreServiceRepresentative.serviceDidLaunch , respectively. The same applies for when an service's termination cycle. Candella services can still hook into these methods by defining similar methods: For launch, CACoreService.service_will_launch and CACoreService.service_did_launch . For teardown, CACoreService.service_will_terminate . Candella services also have two new methods at their disposal that make calls to these methods: CACoreService.launch for launch stages in the services's lifecycle. CACoreService.terminate for termination stages. Whether you want to use the AliceOS-style approach or the new launch/terminate approach is up to you, but remember to keep your logic in a consistent order. If you decide to override the latter methods, be sure to emit the appropriate signals: In launch , emit_signal(\"service_launched\", name=self.__class__.__name__) In terminate , emit_signal(\"service_terminated\") Sending service signals Core services have the ability to emit signals, just like Candella apps; more information on signals can be found in the documentation about the Observable framework . By default, core services emit the following signals: Signal Arguments Purpose service_launched name=self.__class__.__name__ Indicates that the service launched successfully. service_launched_at_login name=self.__class__.__name__ Indicates that the service launched during boot successfully. service_terminated None Indicates the service was terminated successfully. service_requested_notification response=response Indicates that the service sent a notification request and received a response from the user. Service storage Like apps, core services also have access to containerized storage for the currently logged-on user. Details on how to use service storage can be found in the Multiuser framework documentation .","title":"Writing core services"},{"location":"10-candella-service/#writing-core-services","text":"In addition to writing custom apps, Candella offers support for writing custom core services that other apps can rely on. Core services are handled by the CACoreService class and function similarly to Candella apps. Core services also inherit the properties of CAObservable , allowing it to emit signals to observers.","title":"Writing core services"},{"location":"10-candella-service/#creating-a-core-service","text":"The recommended way of creating a core service from scratch is to use the Candella SDK and follow the interactive prompts: candella-sdk --action create --type service Likewise, you can also follow the instructions below to make a core service manually: Create a folder with the structure YourAppName.aosapp inside of the System/CoreServices folder. Create a manifest file inside of the service folder using the manifest structure (see \"The manifest file\" ). Create the Resources/Iconset folders inside of the service directory. Add service icons for the following sizes in pixels (their names will be the corresponding size): 16, 24, 32, 48, 64, 128, 256, 512, 1024. Create a file with your service's name with the rpy extension. Use the template below to fill the contents of your service. # # ServiceName.rpy # Service Name # # (C) Year Author. # init offset = 5 init python: class Service(CACoreService): \"\"\"Service description\"\"\" def __init__(self): CACoreService.__init__( self, AS_CORESERVICES_DIR + \"ServiceName.aoscservice/\" ) # Initialize your core service here. # Initialize the service outside of the class. service = Service()","title":"Creating a core service"},{"location":"10-candella-service/#the-manifest-file","text":"Like Candella apps, core services also include a manifest file that defines the service, as well as its permissions and requisites. This is also located in the root of the service folder and should be named manifest.json . Field What it does name A short name of your service. id An identifier for the service. It is recommended to use reverse domain notation. author The author of the service. It is recommended to use the Name <name@email.server> format. version The current version of the service. description A summary of what your service does. license The license your service falls under as an SPDX expression. permissions A list of strings containing what permissions your service requires. See permissions in the app manifest . requisites (Optional) A list of strings containing the names of the frameworks this service relies on. Unrestricted access Core services typically have unrestricted access to resources, unlike Candella apps, when declared in the manifest. Ensure that you declare only the permissions you need and that you use those resource wisely.","title":"The manifest file"},{"location":"10-candella-service/#validating-service-requisites","text":"Core services that depend on requisite frameworks should be declared in the app's manifest under the requisites field. At initialization time, the service will determine whether or not the frameworks are present.","title":"Validating service requisites"},{"location":"10-candella-service/#core-service-lifecycle","text":"Like Candella apps, core services have a lifecycle based on the structure of AliceOS core services. These methods are called when a stage of the service lifecycle will happen and when the stage has finished; for launch, this would be ASCoreServiceRepresentative.serviceWillLaunch and ASCoreServiceRepresentative.serviceDidLaunch , respectively. The same applies for when an service's termination cycle. Candella services can still hook into these methods by defining similar methods: For launch, CACoreService.service_will_launch and CACoreService.service_did_launch . For teardown, CACoreService.service_will_terminate . Candella services also have two new methods at their disposal that make calls to these methods: CACoreService.launch for launch stages in the services's lifecycle. CACoreService.terminate for termination stages. Whether you want to use the AliceOS-style approach or the new launch/terminate approach is up to you, but remember to keep your logic in a consistent order. If you decide to override the latter methods, be sure to emit the appropriate signals: In launch , emit_signal(\"service_launched\", name=self.__class__.__name__) In terminate , emit_signal(\"service_terminated\")","title":"Core service lifecycle"},{"location":"10-candella-service/#sending-service-signals","text":"Core services have the ability to emit signals, just like Candella apps; more information on signals can be found in the documentation about the Observable framework . By default, core services emit the following signals: Signal Arguments Purpose service_launched name=self.__class__.__name__ Indicates that the service launched successfully. service_launched_at_login name=self.__class__.__name__ Indicates that the service launched during boot successfully. service_terminated None Indicates the service was terminated successfully. service_requested_notification response=response Indicates that the service sent a notification request and received a response from the user.","title":"Sending service signals"},{"location":"10-candella-service/#service-storage","text":"Like apps, core services also have access to containerized storage for the currently logged-on user. Details on how to use service storage can be found in the Multiuser framework documentation .","title":"Service storage"},{"location":"11-notifications/","text":"NotificationKit Changes Candella includes a few improvements to the NotificationKit framework that adds more functionality and modularity to creating notifications with AppKit and NotificationKit screens. Notification banner design Banners in Candella have been moved to the right side of the screen and take up less screen space. They take on the light theme present in the rest of Candella via ScreenKit and use the same fonts. Banners have been positioned so they sit just underneath the top bar in Celeste Shell but also look great in-game. Creating modular banners Notification banners can be generated automatically using the CANotificationBanner class, rather than at call time when invoking CANotification.send_banner . This class offers more control over the appearance of the banner and is typically easier to use than the manual mode in previous releases. To create a banner using CANotificationBanner , create an instance of the object with specified details: banner = CANotificationBanner( \"Message not sent.\", \"The message could not be delivered to the recipient.\") There are three arguments that must be supplied when creating a new banner: message (str): The primary message of the banner. details (str): Supporting text for the banner. This could further explain the main message, or provide additional context. callback (any): The callback to execute when clicking on the action button. Defaults to Return('didClickRespond') . To invoke this banner in a banner request, pass it as a keyword argument in CAApplication.send_banner and set the mode to automatic : response = CANotification.send_banner(mode='automatic', banner=banner) Customizing banners The following attributes are present in CANotificationBanner to let developers customize banners: Attribute Type What it does message str The primary message of the banner. details str The supporting text for the banner. Generally, this explains the primary message or adds additional context. callback callable A Ren'Py callback function to execute when clicking the action button on the banner. Defaults to Return('didClickRespond') . callback_text str The text for the action button. Defaults to \"Respond\" .","title":"NotificationKit Changes"},{"location":"11-notifications/#notificationkit-changes","text":"Candella includes a few improvements to the NotificationKit framework that adds more functionality and modularity to creating notifications with AppKit and NotificationKit screens.","title":"NotificationKit Changes"},{"location":"11-notifications/#notification-banner-design","text":"Banners in Candella have been moved to the right side of the screen and take up less screen space. They take on the light theme present in the rest of Candella via ScreenKit and use the same fonts. Banners have been positioned so they sit just underneath the top bar in Celeste Shell but also look great in-game.","title":"Notification banner design"},{"location":"11-notifications/#creating-modular-banners","text":"Notification banners can be generated automatically using the CANotificationBanner class, rather than at call time when invoking CANotification.send_banner . This class offers more control over the appearance of the banner and is typically easier to use than the manual mode in previous releases. To create a banner using CANotificationBanner , create an instance of the object with specified details: banner = CANotificationBanner( \"Message not sent.\", \"The message could not be delivered to the recipient.\") There are three arguments that must be supplied when creating a new banner: message (str): The primary message of the banner. details (str): Supporting text for the banner. This could further explain the main message, or provide additional context. callback (any): The callback to execute when clicking on the action button. Defaults to Return('didClickRespond') . To invoke this banner in a banner request, pass it as a keyword argument in CAApplication.send_banner and set the mode to automatic : response = CANotification.send_banner(mode='automatic', banner=banner)","title":"Creating modular banners"},{"location":"11-notifications/#customizing-banners","text":"The following attributes are present in CANotificationBanner to let developers customize banners: Attribute Type What it does message str The primary message of the banner. details str The supporting text for the banner. Generally, this explains the primary message or adds additional context. callback callable A Ren'Py callback function to execute when clicking the action button on the banner. Defaults to Return('didClickRespond') . callback_text str The text for the action button. Defaults to \"Respond\" .","title":"Customizing banners"},{"location":"96-design-and-branding/","text":"Design and branding Candella includes utilities and modules that help ensure the system's design language is followed, as well as provide branding images. Design Candella, in large part, follows the Suru design guidelines and is commonly seen in the icons and font (Ubuntu). The CADesign module contains some utilities to help facilitate following the design language. get_app_mask_frame() Returns a Frame object with a mask of the app's general shape. get_app_mask(icon, size) Returns an AlphaMask displayable with the app's general shape masked on to the specified icon with a size of size x size pixels. Branding The Branding directory inside of the System/Library directory contains logomarks and sprites that can be used throughout Candella. Please, do not use these images to represent your app or service. *The logomark is best used on a dark background. Note that, for fonts, the Ubuntu font is used.","title":"Design and branding"},{"location":"96-design-and-branding/#design-and-branding","text":"Candella includes utilities and modules that help ensure the system's design language is followed, as well as provide branding images.","title":"Design and branding"},{"location":"96-design-and-branding/#design","text":"Candella, in large part, follows the Suru design guidelines and is commonly seen in the icons and font (Ubuntu). The CADesign module contains some utilities to help facilitate following the design language.","title":"Design"},{"location":"96-design-and-branding/#get_app_mask_frame","text":"Returns a Frame object with a mask of the app's general shape.","title":"get_app_mask_frame()"},{"location":"96-design-and-branding/#get_app_maskicon-size","text":"Returns an AlphaMask displayable with the app's general shape masked on to the specified icon with a size of size x size pixels.","title":"get_app_mask(icon, size)"},{"location":"96-design-and-branding/#branding","text":"The Branding directory inside of the System/Library directory contains logomarks and sprites that can be used throughout Candella. Please, do not use these images to represent your app or service. *The logomark is best used on a dark background. Note that, for fonts, the Ubuntu font is used.","title":"Branding"},{"location":"97-deprecated/","text":"Deprecations Candella includes a small module that facilitates deprecating functions or restricting function to specific OS versions. @available {label:new} Restrict usage of a function to specific OS versions. This can be used to determine if a method or function should be marked as deprecated, or if a function is only available on a specific minimum OS version. This decorator is inspired by the @available property wrapper in Swift. Information about when the method or function was introduced and deprecated is added to the function's docstring. from store.CADeprecated import available # To mark a function as available for all OS versions. @available(\"*\", introduced=\"bahama\") def new_test_function(): return True # To mark a function as available to a minimum version. @available(\"bahama\", introduced=\"bahama\") def requires_bahama(): return new_test_function() and False # To mark a function as deprecated in a given version. @available(\"*\", deprecated=\"bahama\", message=\"Please use new_test_function instead.\") def is_truthy(): return True Arguments minimum_codename (str): The minimum OS version that this function supports. To support all, use '*'. introduced (str): The OS version that this function was introduced. Defaults to apple-cinnamon. deprecated (str): The OS version that this function was deprecated. Defaults to None. message (str): A message used to mark why something is deprecated or introduced. Defaults to None. @deprecated {label:deprecated} from store.CADeprecated import deprecated @deprecated('21.02') def deprecated_func(): pass When the function is called, a warning message will appear in the console and the Candella log file indicating that the function was deprecated, as well as the reason for the deprecation, if one was specified. Important The deprecated function has been tested on functions and class methods, but hasn't been tested or designed for variables, class fields, or classes themselves. Use with caution. deprecated arguments version (str): The version in which the function will be deprecated. renamed (str): (Optional) What the function has been renamed to, if the function was renamed. reason (str): (Optional) The reason why the function was deprecated.","title":"Deprecations"},{"location":"97-deprecated/#deprecations","text":"Candella includes a small module that facilitates deprecating functions or restricting function to specific OS versions.","title":"Deprecations"},{"location":"97-deprecated/#available","text":"{label:new} Restrict usage of a function to specific OS versions. This can be used to determine if a method or function should be marked as deprecated, or if a function is only available on a specific minimum OS version. This decorator is inspired by the @available property wrapper in Swift. Information about when the method or function was introduced and deprecated is added to the function's docstring. from store.CADeprecated import available # To mark a function as available for all OS versions. @available(\"*\", introduced=\"bahama\") def new_test_function(): return True # To mark a function as available to a minimum version. @available(\"bahama\", introduced=\"bahama\") def requires_bahama(): return new_test_function() and False # To mark a function as deprecated in a given version. @available(\"*\", deprecated=\"bahama\", message=\"Please use new_test_function instead.\") def is_truthy(): return True","title":"@available"},{"location":"97-deprecated/#arguments","text":"minimum_codename (str): The minimum OS version that this function supports. To support all, use '*'. introduced (str): The OS version that this function was introduced. Defaults to apple-cinnamon. deprecated (str): The OS version that this function was deprecated. Defaults to None. message (str): A message used to mark why something is deprecated or introduced. Defaults to None.","title":"Arguments"},{"location":"97-deprecated/#deprecated","text":"{label:deprecated} from store.CADeprecated import deprecated @deprecated('21.02') def deprecated_func(): pass When the function is called, a warning message will appear in the console and the Candella log file indicating that the function was deprecated, as well as the reason for the deprecation, if one was specified. Important The deprecated function has been tested on functions and class methods, but hasn't been tested or designed for variables, class fields, or classes themselves. Use with caution.","title":"@deprecated"},{"location":"97-deprecated/#deprecated-arguments","text":"version (str): The version in which the function will be deprecated. renamed (str): (Optional) What the function has been renamed to, if the function was renamed. reason (str): (Optional) The reason why the function was deprecated.","title":"deprecated arguments"},{"location":"98-stop-errors/","text":"Common Stop Errors If Candella encounters an issue that prompts restarting the game (or forcefully quitting it), a Stop error will be displayed on screen. These Stop error screens will display a code that can be used to identify the problem and look for possible solutions. REQUISITE_FRAMEWORK_MISSING An app, core service, or framework is requiring a framework that doesn't exist on the system, or it cannot detect the framework it's looking for. Common factors that produce this error An app, core service, or framework has a misspelling in the framework name in the requisites field of the project's manifest. The framework the app, core service, or framework is looking for isn't installed in the distribution of Candella. Possible solutions Check the requisites field in the manifest.json file of the project. Check that the framework exists in the default framework directory (typically System/Frameworks/ ). Reinstall the distribution. MISSING_OOBE_SERVICE A core service that provides an out-of-box experience or setup assistant could not be found. This usually occurs when the Roland Boot Manager attempts to run a setup assistant and cannot detect one. Common factors that produce this error Either the AliceOS Setup Assistant or Thorax core service is missing. Possible solutions Reinstall the distribution.","title":"Common Stop Errors"},{"location":"98-stop-errors/#common-stop-errors","text":"If Candella encounters an issue that prompts restarting the game (or forcefully quitting it), a Stop error will be displayed on screen. These Stop error screens will display a code that can be used to identify the problem and look for possible solutions.","title":"Common Stop Errors"},{"location":"98-stop-errors/#requisite_framework_missing","text":"An app, core service, or framework is requiring a framework that doesn't exist on the system, or it cannot detect the framework it's looking for.","title":"REQUISITE_FRAMEWORK_MISSING"},{"location":"98-stop-errors/#common-factors-that-produce-this-error","text":"An app, core service, or framework has a misspelling in the framework name in the requisites field of the project's manifest. The framework the app, core service, or framework is looking for isn't installed in the distribution of Candella.","title":"Common factors that produce this error"},{"location":"98-stop-errors/#possible-solutions","text":"Check the requisites field in the manifest.json file of the project. Check that the framework exists in the default framework directory (typically System/Frameworks/ ). Reinstall the distribution.","title":"Possible solutions"},{"location":"98-stop-errors/#missing_oobe_service","text":"A core service that provides an out-of-box experience or setup assistant could not be found. This usually occurs when the Roland Boot Manager attempts to run a setup assistant and cannot detect one.","title":"MISSING_OOBE_SERVICE"},{"location":"98-stop-errors/#common-factors-that-produce-this-error_1","text":"Either the AliceOS Setup Assistant or Thorax core service is missing.","title":"Common factors that produce this error"},{"location":"98-stop-errors/#possible-solutions_1","text":"Reinstall the distribution.","title":"Possible solutions"},{"location":"99-candella-sdk/","text":"Candella SDK The Candella SDK application is a command-line utility that aims to make Candella development easier. The SDK provides utilities to create apps, core services, and frameworks automagically with an interactive tool. Quickstart: Install from PyPI To install the Candella SDK, you can run the following command via PyPI: pip install candella-sdk Warning The Candella SDK is in a pre-release state. Features, methods, and APIs may change over time. Build the SDK from source You will need the following dependencies installed: Python 3.8 or greater Poetry 1.1.4 or greater Clone the project from GitHub and run the following commands in the root of the project: poetry install poetry build Then, use pip install and point to the resulting wheel file in the dist directory. Creating projects Currently, the Candella SDK lets you create three different kinds of projects: applications, core services, and frameworks. To create any of these projects, run candella-sdk --action create and specify the --type argument: --type app to create an application. --type service to create a core service. --type framework to create a framework. Note If you choose an open-source license, you will need to supply the LICENSE file with your app. This may be updated in a future release of the SDK. Validating projects The Candella SDK provides a rudimentary validation system for projects to ensure that apps, core services, and frameworks have proper manifests and the materials needed for the project to run in Candella. To start validating a project, run candella-sdk --action validate and specify the --project argument with the path to your project. Currently, the SDK will check for the following: That the project is a valid Candella project That the project contains a manifest file That the project's manifest file contains the required keys and doesn't include invalid keys That the project contains the proper iconset if the project is an app or core service About project validation Remember that project validation is not a substitution for thorough testing, nor does it guarantee that your project will work correctly with Candella. Always remember to thoroughly test your projects and how they work in the most recent versions of Candella alongside the most recent versions of the frameworks and core services included. Using Candella SDK programmatically The Candella SDK can be imported as a Python module into a script to automate development or to write tests for validating apps. Creating a project can be performed by calling sdk.create with a single argument that defines the project type: from candella_sdk import sdk, CandellaProjectType sdk.create(CandellaProjectType.application) Likewise, a project can be validated programmatically by calling sdk.validate and passing in the path to the project to validate. The validation function returns a tuple containing if the project was validated, and the error in question if the validation failed. from candella_sdk import sdk validated, error = sdk.validate(\"path/to/Example.aosapp\") if not validated: raise Exception(error)","title":"Candella SDK"},{"location":"99-candella-sdk/#candella-sdk","text":"The Candella SDK application is a command-line utility that aims to make Candella development easier. The SDK provides utilities to create apps, core services, and frameworks automagically with an interactive tool.","title":"Candella SDK"},{"location":"99-candella-sdk/#quickstart-install-from-pypi","text":"To install the Candella SDK, you can run the following command via PyPI: pip install candella-sdk Warning The Candella SDK is in a pre-release state. Features, methods, and APIs may change over time.","title":"Quickstart: Install from PyPI"},{"location":"99-candella-sdk/#build-the-sdk-from-source","text":"You will need the following dependencies installed: Python 3.8 or greater Poetry 1.1.4 or greater Clone the project from GitHub and run the following commands in the root of the project: poetry install poetry build Then, use pip install and point to the resulting wheel file in the dist directory.","title":"Build the SDK from source"},{"location":"99-candella-sdk/#creating-projects","text":"Currently, the Candella SDK lets you create three different kinds of projects: applications, core services, and frameworks. To create any of these projects, run candella-sdk --action create and specify the --type argument: --type app to create an application. --type service to create a core service. --type framework to create a framework. Note If you choose an open-source license, you will need to supply the LICENSE file with your app. This may be updated in a future release of the SDK.","title":"Creating projects"},{"location":"99-candella-sdk/#validating-projects","text":"The Candella SDK provides a rudimentary validation system for projects to ensure that apps, core services, and frameworks have proper manifests and the materials needed for the project to run in Candella. To start validating a project, run candella-sdk --action validate and specify the --project argument with the path to your project. Currently, the SDK will check for the following: That the project is a valid Candella project That the project contains a manifest file That the project's manifest file contains the required keys and doesn't include invalid keys That the project contains the proper iconset if the project is an app or core service About project validation Remember that project validation is not a substitution for thorough testing, nor does it guarantee that your project will work correctly with Candella. Always remember to thoroughly test your projects and how they work in the most recent versions of Candella alongside the most recent versions of the frameworks and core services included.","title":"Validating projects"},{"location":"99-candella-sdk/#using-candella-sdk-programmatically","text":"The Candella SDK can be imported as a Python module into a script to automate development or to write tests for validating apps. Creating a project can be performed by calling sdk.create with a single argument that defines the project type: from candella_sdk import sdk, CandellaProjectType sdk.create(CandellaProjectType.application) Likewise, a project can be validated programmatically by calling sdk.validate and passing in the path to the project to validate. The validation function returns a tuple containing if the project was validated, and the error in question if the validation failed. from candella_sdk import sdk validated, error = sdk.validate(\"path/to/Example.aosapp\") if not validated: raise Exception(error)","title":"Using Candella SDK programmatically"}]}